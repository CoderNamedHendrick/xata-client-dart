import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';

void main () async {
  var dio = Dio();
  final Response result =  await dio.get('https://docs.xata.io/api/openapi');

  if (result.statusCode == 200) {
    schemas(result);
  }
}

void schemas(Response<dynamic> result) {
  var file = File('lib/src/api/schemas.dart');
  var modelFile = File('lib/src/api/models.dart');
  var sink = file.openWrite();
  var modelSink = modelFile.openWrite();

  sink.writeln("part 'models.dart';\n");
  sink.writeln("/// This file was generated by xata-client OpenAPI code-gen \n");
  modelSink.writeln("part of 'schemas.dart';\n");
  modelSink.writeln("/// This file was generated by xata-client OpenAPI code-gen \n");


  final Map<String, dynamic> json = jsonDecode(result.data);
  final Map schemas = (json['components']['schemas'] as Map);
  for (var key in schemas.keys) {
    final schemaProperties = schemas[key] as Map;
    print(schemaProperties.keys);
    // dealing with schemas with type string
    if (schemaProperties['type'] == 'string' && (schemaProperties['title'] != null || schemaProperties['enum'] != null)){
      if (schemaProperties['enum'] != null){
        var enums = schemaProperties['enum'] as List;

        sink.write('enum $key {');
        for (var e in enums) {
          sink.write('$e,');
        }
        sink.writeln('}');
      } else if (schemaProperties['title'] != null) {
        sink.writeln('typedef ${schemaProperties['title']} = String;');
      }
    }

    // dealing with schemas with type array
    if (schemaProperties['type'] == 'array' && schemaProperties['items'] != null) {
      if (schemaProperties['items']['type'] == 'string'){
        sink.writeln('typedef $key = List<String>;');
      }
    }

    // dealing with schemas of oneOf
    if (schemaProperties.containsKey('oneOf')){
      var listOneOf = schemaProperties['oneOf'] as List;
      modelSink.writeln("class $key<T> {");
      modelSink.writeln("\tlate final T value;");
      List types = [];
      for (var mapData in listOneOf){
        var data = mapData as Map;
        if (data['\$ref'] != null) {
          var pathSplit = (data["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            types.add('List<${pathSplit[pathSplit.length - 1]}>');
          }
        }

        if (data['type'] == 'string'){
          types.add('String');
        } else if (data['type'] == 'number'){
          types.add('num');
        } else if (data['type'] == 'array'){
          if (data['items']['type'] == 'string'){
            types.add('List<String>');
          }

          if (data['items']['\$ref'] != null){
            var pathSplit = (data['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add('List<${pathSplit[pathSplit.length - 1]}>');
            }
          }

          if (data['items']['type'] == 'object'){
            if (data['items']['additionalProperties']['\$ref'] != null) {
              var pathSplit = (data['items']['additionalProperties']["\$ref"] as String).split('/');
              if (pathSplit[pathSplit.length - 2] == "schemas") {
                types.add('List<${pathSplit[pathSplit.length - 1]}>');
              }
            }
          }
        } else if (data['type'] == 'object') {
          if (data['additionalProperties']['\$ref'] != null) {
            var pathSplit = (data['additionalProperties']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add(pathSplit[pathSplit.length - 1]);
            }
          }
        }
      }
      modelSink.writeln("\t$key(T value) {");
      modelSink.write("\t\tif (");
      for (var i = 0 ; i < types.length; i++) {
        modelSink.write("value is ${types[i]}");
        if (i != types.length - 1){
          modelSink.write(" || ");
        }
      }
      modelSink.writeln(") {");
      modelSink.writeln("\t\t\tthis.value = value;");
      modelSink.writeln("\t\t} else {");
      modelSink.write("\t\t\tthrow Exception('$key must be of type ");
      for (var i = 0 ; i < types.length; i++) {
        modelSink.write("${types[i]}");
        if (i != types.length - 1){
          modelSink.write(" or ");
        }
      }
      modelSink.writeln("');");
      modelSink.writeln("\t\t}");

      modelSink.writeln("\t}");

      modelSink.writeln("}");
    }

    // dealing with schemas of anyOf
    if (schemaProperties.containsKey('anyOf')){
      var listOneOf = schemaProperties['anyOf'] as List;
      modelSink.writeln("class $key<T> {");
      modelSink.writeln("\tlate final T value;");
      List types = [];
      for (var mapData in listOneOf){
        var data = mapData as Map;
        if (data['\$ref'] != null) {
          var pathSplit = (data["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            types.add('List<${pathSplit[pathSplit.length - 1]}>');
          }
        }

        if (data['type'] == 'string'){
          types.add('String');
        } else if (data['type'] == 'number'){
          types.add('num');
        } else if (data['type'] == 'boolean') {
          types.add('bool');
        }
        else if (data['type'] == 'array'){
          if (data['items']['type'] == 'string'){
            types.add('List<String>');
          }

          if (data['items']['\$ref'] != null){
            var pathSplit = (data['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add('List<${pathSplit[pathSplit.length - 1]}>');
            }
          }

          if (data['items']['type'] == 'object'){
            if (data['items']['additionalProperties']['\$ref'] != null) {
              var pathSplit = (data['items']['additionalProperties']["\$ref"] as String).split('/');
              if (pathSplit[pathSplit.length - 2] == "schemas") {
                types.add('List<${pathSplit[pathSplit.length - 1]}>');
              }
            }
          }
        } else if (data['type'] == 'object') {
          if (data['additionalProperties']['\$ref'] != null) {
            var pathSplit = (data['additionalProperties']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add(pathSplit[pathSplit.length - 1]);
            }
          }
        }
      }
      modelSink.writeln("\t$key(T value) {");
      modelSink.write("\t\tif (");
      for (var i = 0 ; i < types.length; i++) {
        modelSink.write("value is ${types[i]}");
        if (i != types.length - 1){
          modelSink.write(" || ");
        }
      }
      modelSink.writeln(") {");
      modelSink.writeln("\t\t\tthis.value = value;");
      modelSink.writeln("\t\t} else {");
      modelSink.write("\t\t\tthrow Exception('$key must be of type ");
      for (var i = 0 ; i < types.length; i++) {
        modelSink.write("${types[i]}");
        if (i != types.length - 1){
          modelSink.write(" or ");
        }
      }
      modelSink.writeln("');");
      modelSink.writeln("\t\t}");

      modelSink.writeln("\t}");

      modelSink.writeln("}");
    }

    // dealing with schemas of allOf
    if (schemaProperties.containsKey('allOf')) {
      // TODO: allOf case
    }

    // dealing with schemas of type object
    if (schemaProperties['type'] == 'object') {
      final Map properties = schemaProperties['properties'] as Map;
      modelSink.writeln("class $key {");
      Map types = {};

      // writing constructor for model classes
      for (var property in properties.keys) {
        if (properties[property]['type'] == 'string' || properties[property]['enum'] != null) {
          if(properties[property]['enum'] != null) {
            var enums = properties[property]['enum'] as List;

            sink.write('enum ${property.toString().toUpperCase()} {');
            for (var e in enums) {
              sink.write('$e,');
            }
            sink.writeln('}');

            modelSink.writeln('\tfinal ${property.toString().toUpperCase()} ${property == 'new' ? '$property$key' : '$property'};');
            types[property] = property.toString().toUpperCase();
          } else {
            modelSink.writeln("\tfinal String ${property == 'new' ? '$property$key' : '$property'};");
            types[property] = 'String';
          }
        }


        if (properties[property]["\$ref"] != null){
          var pathSplit = (properties[property]["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            modelSink.writeln(
                "\tfinal ${pathSplit[pathSplit.length - 1]} ${property == 'new' ? '$property$key' : '$property'};");
            types[property] = pathSplit[pathSplit.length - 1];
          }
        }

        if (properties[property]['type']  != null && properties[property]['items'] != null) {
          if (properties[property]['items']["\$ref"] != null){
            var pathSplit = (properties[property]['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              modelSink.writeln(
                  "\tfinal List<${pathSplit[pathSplit.length - 1]}> $property;");
              types[property] = 'List<${pathSplit[pathSplit.length - 1]}>';
            }
          }
        }
      }

      modelSink.write("\tconst $key(${types.isEmpty ? '' : '{'}");
      for (var type in types.keys) {
        modelSink.write("required this.${type == 'new' ? '$type$key' : '$type'},");
      }
      modelSink.writeln("${types.isEmpty ? '' : '}'});");
      // end of the constructor

      // TODO: take care of enums
      // toJson function
      modelSink.writeln("\tMap<String, dynamic> toJson() => {");
      for (var type in types.keys) {
        modelSink.writeln("\t\t'${type.contains('\$') ? '\\$type' : type}' : ${type == 'new' ? '$type$key' : '$type'},");
      }
      modelSink.writeln("\t};");

      // end of class block
      modelSink.writeln("}\n");
    }

  }

  sink.close();
  modelSink.close();
}