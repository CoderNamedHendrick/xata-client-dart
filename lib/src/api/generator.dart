import 'dart:convert';
import 'dart:io';

import 'package:dio/dio.dart';

void main() async {
  var dio = Dio();
  final Response result = await dio.get('https://docs.xata.io/api/openapi');

  if (result.statusCode == 200) {
    schemas(result);
    responses(result);
    parameters(result);
  }
}

void parameters(Response<dynamic> result) {
  var file = File('lib/src/api/parameters.dart');
  var sink = file.openWrite();

  sink.writeln("part of 'schemas.dart';\n");

  final Map<String, dynamic> json = jsonDecode(result.data);
  final Map parameters = (json["components"]["parameters"] as Map);

  for (var key in parameters.keys) {
    final parameter = parameters[key] as Map;

    if (parameter["schema"]["\$ref"] != null) {
      var pathSplit = (parameter["schema"]["\$ref"] as String).split('/');
      if (pathSplit[pathSplit.length - 2] == "schemas") {
        sink.writeln('typedef $key = ${pathSplit[pathSplit.length - 1]};');
      }
    }
  }
  sink.close();
}

void responses(Response<dynamic> result) {
  var file = File('lib/src/api/responses.dart');
  var sink = file.openWrite();
  sink.writeln("part of 'schemas.dart';\n");

  sink.writeln(
      "/// This file was generated by xata-client OpenAPI code-gen \n");

  final Map<String, dynamic> json = jsonDecode(result.data);
  final Map responses = (json["components"]["responses"] as Map);
  for (var key in responses.keys) {
    final responseProperties = responses[key] as Map;
    print(responseProperties.keys);

    final schemaProperties =
        (responseProperties["content"]["application/json"]["schema"] as Map);

    // dealing with schemas of type object
    if (schemaProperties['type'] == 'object') {
      final List? requiredTypes = schemaProperties["required"] as List?;
      if (schemaProperties['example'] != null) {
        sink.writeln("/// example ${schemaProperties["example"]} \n");
      }
      final Map properties = schemaProperties['properties'] as Map;
      sink.writeln("class $key {");
      Map types = {};

      // writing constructor for model classes
      for (var property in properties.keys) {
        if (properties[property]['type'] == 'string') {
          sink.writeln(
              "\tfinal String${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} ${property == 'new' ? '$property$key' : '$property'};");
          types[property] = 'String';
        }

        if (properties[property]['type'] == 'integer') {
          sink.writeln(
              "\tfinal int${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} $property;");
          types[property] = 'int';
        }

        if (properties[property]["\$ref"] != null) {
          var pathSplit = (properties[property]["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            sink.writeln(
                "\tfinal ${pathSplit[pathSplit.length - 1]}${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} ${property == 'new' ? '$property$key' : '$property'};");
            types[property] = pathSplit[pathSplit.length - 1];
          }
        }

        if (properties[property]['type'] != null &&
            properties[property]['items'] != null) {
          if (properties[property]['items']["\$ref"] != null) {
            var pathSplit =
                (properties[property]['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              sink.writeln(
                  "\tfinal List<${pathSplit[pathSplit.length - 1]}>${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} $property;");
              types[property] = 'List<${pathSplit[pathSplit.length - 1]}>';
            }
          }
        }
      }

      sink.write("\tconst $key(${types.isEmpty ? '' : '{'}");
      for (var type in types.keys) {
        sink.write(
            "${requiredTypes != null && requiredTypes.contains(type) ? 'required ' : ''}this.${type == 'new' ? '$type$key' : '$type'},");
      }
      sink.writeln("${types.isEmpty ? '' : '}'});");
      // end of the constructor

      // toJson function
      sink.writeln("\tMap<String, dynamic> toJson() => {");
      for (var type in types.keys) {
        sink.writeln("\t\t'${type.contains('\$') ? '\\$type' : type}' : ${[
              'String',
              'int',
            ].contains((types[type] as String)) || (types[type] as String).contains('List') ? type == 'new' ? '$type$key' : '$type' : '${type == 'new' ? '$type$key' : '$type'}' '.toJson()'},");
      }
      sink.writeln("\t};\n");

      // fromJson function
      sink.writeln(
          "\tfactory $key.fromJson(Map<String, dynamic> json) => $key(");
      for (var type in types.keys) {
        final fromJsonString = [
                  'String',
                  'int',
                ].contains((types[type] as String)) ||
                (types[type] as String).contains('List')
            ? 'json["${type.contains('\$') ? '\\$type' : type}"]'
            : '${types["$type"]}'
                '.fromJson(json["${type.contains('\$') ? '\\$type' : type}"])';
        sink.writeln("\t\t$type: $fromJsonString,");
      }
      sink.writeln("\t);\n");

      // end of class block
      sink.writeln("}\n");
    }
  }

  sink.close();
}

void schemas(Response<dynamic> result) {
  var file = File('lib/src/api/schemas.dart');
  var modelFile = File('lib/src/api/models.dart');
  var sink = file.openWrite();
  var modelSink = modelFile.openWrite();

  sink.writeln("part 'models.dart';\n");
  sink.writeln("part 'responses.dart';\n");
  sink.writeln("part 'parameters.dart';\n");

  sink.writeln(
      "/// This file was generated by xata-client OpenAPI code-gen \n");
  modelSink.writeln("part of 'schemas.dart';\n");
  modelSink.writeln(
      "/// This file was generated by xata-client OpenAPI code-gen \n");

  final Map<String, dynamic> json = jsonDecode(result.data);
  final Map schemas = (json['components']['schemas'] as Map);
  List<String> schemaTypes = [];
  getTypesAndEnums(schemas, sink, schemaTypes);

  for (var key in schemas.keys) {
    final schemaProperties = schemas[key] as Map;
    print(schemaProperties.keys);
    // dealing with schemas with type string

    // dealing with schemas of oneOf
    if (schemaProperties.containsKey('oneOf')) {
      var listOneOf = schemaProperties['oneOf'] as List;
      modelSink.writeln("class $key<T> {");
      modelSink.writeln("\tlate final T value;");
      List types = [];
      for (var mapData in listOneOf) {
        var data = mapData as Map;
        if (data['\$ref'] != null) {
          var pathSplit = (data["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            types.add('List<${pathSplit[pathSplit.length - 1]}>');
          }
        }

        if (data['type'] == 'string') {
          types.add('String');
        } else if (data['type'] == 'number') {
          types.add('num');
        } else if (data['type'] == 'array') {
          if (data['items']['type'] == 'string') {
            types.add('List<String>');
          }

          if (data['items']['\$ref'] != null) {
            var pathSplit = (data['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add('List<${pathSplit[pathSplit.length - 1]}>');
            }
          }

          if (data['items']['type'] == 'object') {
            if (data['items']['additionalProperties']['\$ref'] != null) {
              var pathSplit =
                  (data['items']['additionalProperties']["\$ref"] as String)
                      .split('/');
              if (pathSplit[pathSplit.length - 2] == "schemas") {
                types.add('List<${pathSplit[pathSplit.length - 1]}>');
              }
            }
          }
        } else if (data['type'] == 'object') {
          if (data['additionalProperties']['\$ref'] != null) {
            var pathSplit =
                (data['additionalProperties']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add(pathSplit[pathSplit.length - 1]);
            }
          }
        }
      }
      modelSink.writeln("\t$key(T value) {");
      modelSink.write("\t\tif (");
      for (var i = 0; i < types.length; i++) {
        modelSink.write("value is ${types[i]}");
        if (i != types.length - 1) {
          modelSink.write(" || ");
        }
      }
      modelSink.writeln(") {");
      modelSink.writeln("\t\t\tthis.value = value;");
      modelSink.writeln("\t\t} else {");
      modelSink.write("\t\t\tthrow Exception('$key must be of type ");
      for (var i = 0; i < types.length; i++) {
        modelSink.write("${types[i]}");
        if (i != types.length - 1) {
          modelSink.write(" or ");
        }
      }
      modelSink.writeln("');");
      modelSink.writeln("\t\t}");

      modelSink.writeln("\t}\n");

      // toJson function
      modelSink.writeln("\tMap<String, dynamic> toJson() => {");
      modelSink.writeln("\t\t'$key': value,");
      modelSink.writeln("\t};\n");

      // fromJson function
      modelSink.writeln(
          "\tfactory $key.fromJson(Map<String, dynamic> json) => $key(");
      modelSink.writeln("\t\tjson['$key'],");
      modelSink.writeln("\t);\n");

      modelSink.writeln("}");
    }

    // dealing with schemas of anyOf
    if (schemaProperties.containsKey('anyOf')) {
      var listOneOf = schemaProperties['anyOf'] as List;
      modelSink.writeln("class $key<T> {");
      modelSink.writeln("\tlate final T value;");
      List types = [];
      for (var mapData in listOneOf) {
        var data = mapData as Map;
        if (data['\$ref'] != null) {
          var pathSplit = (data["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            types.add('List<${pathSplit[pathSplit.length - 1]}>');
          }
        }

        if (data['type'] == 'string') {
          types.add('String');
        } else if (data['type'] == 'number') {
          types.add('num');
        } else if (data['type'] == 'boolean') {
          types.add('bool');
        } else if (data['type'] == 'array') {
          if (data['items']['type'] == 'string') {
            types.add('List<String>');
          }

          if (data['items']['\$ref'] != null) {
            var pathSplit = (data['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add('List<${pathSplit[pathSplit.length - 1]}>');
            }
          }

          if (data['items']['type'] == 'object') {
            if (data['items']['additionalProperties']['\$ref'] != null) {
              var pathSplit =
                  (data['items']['additionalProperties']["\$ref"] as String)
                      .split('/');
              if (pathSplit[pathSplit.length - 2] == "schemas") {
                types.add('List<${pathSplit[pathSplit.length - 1]}>');
              }
            }
          }
        } else if (data['type'] == 'object') {
          if (data['additionalProperties']['\$ref'] != null) {
            var pathSplit =
                (data['additionalProperties']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              types.add(pathSplit[pathSplit.length - 1]);
            }
          }
        }
      }
      modelSink.writeln("\t$key(T value) {");
      modelSink.write("\t\tif (");
      for (var i = 0; i < types.length; i++) {
        modelSink.write("value is ${types[i]}");
        if (i != types.length - 1) {
          modelSink.write(" || ");
        }
      }
      modelSink.writeln(") {");
      modelSink.writeln("\t\t\tthis.value = value;");
      modelSink.writeln("\t\t} else {");
      modelSink.write("\t\t\tthrow Exception('$key must be of type ");
      for (var i = 0; i < types.length; i++) {
        modelSink.write("${types[i]}");
        if (i != types.length - 1) {
          modelSink.write(" or ");
        }
      }
      modelSink.writeln("');");
      modelSink.writeln("\t\t}");

      modelSink.writeln("\t}");

      modelSink.writeln("}");
    }

    // dealing with schemas of allOf
    if (schemaProperties.containsKey('allOf')) {
      // TODO: allOf case
    }

    // dealing with schemas of type object
    if (schemaProperties['type'] == 'object') {
      final Map properties = schemaProperties['properties'] as Map;
      modelSink.writeln("class $key {");
      List? requiredTypes = schemaProperties['required'] as List?;
      Map types = {};

      // writing constructor for model classes
      for (var property in properties.keys) {
        if (properties[property]['type'] == 'string' ||
            properties[property]['enum'] != null) {
          if (properties[property]['enum'] != null) {
            var enums = properties[property]['enum'] as List;

            sink.write('enum ${property.toString().toUpperCase()} {');
            for (var e in enums) {
              sink.write('$e,');
            }
            sink.writeln('}');

            modelSink.writeln(
                '\tfinal ${property.toString().toUpperCase()}${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} ${property == 'new' ? '$property$key' : '$property'};');
            types[property] = property.toString().toUpperCase();
            schemaTypes.add(property.toString().toUpperCase());
          } else {
            modelSink.writeln(
                "\tfinal String${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} ${property == 'new' ? '$property$key' : '$property'};");
            types[property] = 'String';
          }
        }

        if (properties[property]["\$ref"] != null) {
          var pathSplit = (properties[property]["\$ref"] as String).split('/');
          if (pathSplit[pathSplit.length - 2] == "schemas") {
            modelSink.writeln(
                "\tfinal ${pathSplit[pathSplit.length - 1]}${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} ${property == 'new' ? '$property$key' : '$property'};");
            types[property] = pathSplit[pathSplit.length - 1];
          }
        }

        if (properties[property]['type'] != null &&
            properties[property]['items'] != null) {
          if (properties[property]['items']["\$ref"] != null) {
            var pathSplit =
                (properties[property]['items']["\$ref"] as String).split('/');
            if (pathSplit[pathSplit.length - 2] == "schemas") {
              modelSink.writeln(
                  "\tfinal List<${pathSplit[pathSplit.length - 1]}>${requiredTypes != null && requiredTypes.contains(property) ? '' : '?'} $property;");
              types[property] = 'List<${pathSplit[pathSplit.length - 1]}>';
            }
          }
        }
      }

      modelSink.write("\tconst $key(${types.isEmpty ? '' : '{'}");
      for (var type in types.keys) {
        modelSink.write(
            "${requiredTypes != null && requiredTypes.contains(type) ? 'required ' : ''}this.${type == 'new' ? '$type$key' : '$type'},");
      }
      modelSink.writeln("${types.isEmpty ? '' : '}'});");
      // end of the constructor

      // TODO: take care of enums
      // toJson function
      modelSink.writeln("\tMap<String, dynamic> toJson() => {");
      for (var type in types.keys) {
        modelSink.writeln(
            "\t\t'${type.contains('\$') ? '\\$type' : type}' : ${type == 'new' ? '$type$key' : '$type'},");
      }
      modelSink.writeln("\t};\n");

      // fromJson function
      modelSink.writeln(
          "\tfactory $key.fromJson(Map<String, dynamic> json) => $key(");
      for (var type in types.keys) {
        final fromJsonString = [
                  'String',
                  'int',
                  ...schemaTypes,
                ].contains((types[type] as String)) ||
                (types[type] as String).contains('List')
            ? 'json["${type.contains('\$') ? '\\$type' : type == 'new' ? '$type$key' : '$type'}"]'
            : '${types["$type"]}'
                '.fromJson(json["${type.contains('\$') ? '\\$type' : type}"])';
        modelSink.writeln(
            "\t\t${type == 'new' ? '$type$key' : '$type'}: $fromJsonString,");
      }
      modelSink.writeln("\t);\n");

      // end of class block
      modelSink.writeln("}\n");
    }
  }
  sink.close();
  modelSink.close();
}

void getTypesAndEnums(
    Map<dynamic, dynamic> schemas, IOSink sink, List<String> schemaTypes) {
  for (var key in schemas.keys) {
    final schemaProperties = schemas[key] as Map;
    if (schemaProperties['type'] == 'string' &&
        (schemaProperties['title'] != null ||
            schemaProperties['enum'] != null)) {
      if (schemaProperties['enum'] != null) {
        var enums = schemaProperties['enum'] as List;

        sink.write('enum $key {');
        for (var e in enums) {
          sink.write('$e,');
        }
        sink.writeln('}');
        schemaTypes.add(key as String);
      } else if (schemaProperties['title'] != null) {
        sink.writeln('typedef ${schemaProperties['title']} = String;');
        schemaTypes.add(schemaProperties['title'] as String);
      }
    }

    // dealing with schemas with type array
    if (schemaProperties['type'] == 'array' &&
        schemaProperties['items'] != null) {
      if (schemaProperties['items']['type'] == 'string') {
        sink.writeln('typedef $key = List<String>;');
      }
    }
  }
}
