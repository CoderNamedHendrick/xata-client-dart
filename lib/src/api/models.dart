part of 'schemas.dart';

/// This file was generated by xata-client OpenAPI code-gen 

class Branch {
	final String name;
	final DateTime createdAt;
	const Branch({required this.name,required this.createdAt,});
	Map<String, dynamic> toJson() => {
		'name' : name,
		'createdAt' : createdAt,
	};

	factory Branch.fromJson(Map<String, dynamic> json) => Branch(
		name: json["name"],
		createdAt: json["createdAt"],
	);

}

class BranchMetadata {
	final String? repository;
	final BranchName? branch;
	final String? stage;
	const BranchMetadata({this.repository,this.branch,this.stage,});
	Map<String, dynamic> toJson() => {
		'repository' : repository,
		'branch' : branch,
		'stage' : stage,
	};

	factory BranchMetadata.fromJson(Map<String, dynamic> json) => BranchMetadata(
		repository: json["repository"],
		branch: json["branch"],
		stage: json["stage"],
	);

}

class BranchMigration {
	final String? id;
	final String? parentID;
	final String status;
	final String? title;
	final String? lastGitRevision;
	final DateTime? createdAt;
	final List<TableRename>? renamedTables;
	const BranchMigration({this.id,this.parentID,required this.status,this.title,this.lastGitRevision,this.createdAt,this.renamedTables,});
	Map<String, dynamic> toJson() => {
		'id' : id,
		'parentID' : parentID,
		'status' : status,
		'title' : title,
		'lastGitRevision' : lastGitRevision,
		'createdAt' : createdAt,
		'renamedTables' : renamedTables,
	};

	factory BranchMigration.fromJson(Map<String, dynamic> json) => BranchMigration(
		id: json["id"],
		parentID: json["parentID"],
		status: json["status"],
		title: json["title"],
		lastGitRevision: json["lastGitRevision"],
		createdAt: json["createdAt"],
		renamedTables: json["renamedTables"],
	);

}

class Column {
	final String name;
	final TYPE type;
	final List<Column>? columns;
	const Column({required this.name,required this.type,this.columns,});
	Map<String, dynamic> toJson() => {
		'name' : name,
		'type' : type,
		'columns' : columns,
	};

	factory Column.fromJson(Map<String, dynamic> json) => Column(
		name: json["name"],
		type: json["type"],
		columns: json["columns"],
	);

}

class ColumnMigration {
	final Column old;
	final Column newColumnMigration;
	const ColumnMigration({required this.old,required this.newColumnMigration,});
	Map<String, dynamic> toJson() => {
		'old' : old,
		'new' : newColumnMigration,
	};

	factory ColumnMigration.fromJson(Map<String, dynamic> json) => ColumnMigration(
		old: Column.fromJson(json["old"]),
		newColumnMigration: Column.fromJson(json["new"]),
	);

}

class DBBranch {
	final DBName databaseName;
	final BranchName branchName;
	final DateTime createdAt;
	final String id;
	final String lastMigrationID;
	final BranchMetadata? metadata;
	final StartedFromMetadata? startedFrom;
	final Schema schema;
	const DBBranch({required this.databaseName,required this.branchName,required this.createdAt,required this.id,required this.lastMigrationID,this.metadata,this.startedFrom,required this.schema,});
	Map<String, dynamic> toJson() => {
		'databaseName' : databaseName,
		'branchName' : branchName,
		'createdAt' : createdAt,
		'id' : id,
		'lastMigrationID' : lastMigrationID,
		'metadata' : metadata,
		'startedFrom' : startedFrom,
		'schema' : schema,
	};

	factory DBBranch.fromJson(Map<String, dynamic> json) => DBBranch(
		databaseName: json["databaseName"],
		branchName: json["branchName"],
		createdAt: json["createdAt"],
		id: json["id"],
		lastMigrationID: json["lastMigrationID"],
		metadata: BranchMetadata.fromJson(json["metadata"]),
		startedFrom: StartedFromMetadata.fromJson(json["startedFrom"]),
		schema: Schema.fromJson(json["schema"]),
	);

}

class FilterColumn<T> {
	late final T value;
	FilterColumn(T value) {
		if (value is List<FilterColumnIncludes> || value is List<FilterPredicate> || value is List<FilterList>) {
			this.value = value;
		} else {
			throw Exception('FilterColumn must be of type List<FilterColumnIncludes> or List<FilterPredicate> or List<FilterList>');
		}
	}
}
class FilterColumnIncludes {
	final FilterPredicate? $includes;
	final FilterPredicate? $includesAny;
	final FilterPredicate? $includesAll;
	final FilterPredicate? $includesNone;
	const FilterColumnIncludes({this.$includes,this.$includesAny,this.$includesAll,this.$includesNone,});
	Map<String, dynamic> toJson() => {
		'\$includes' : $includes,
		'\$includesAny' : $includesAny,
		'\$includesAll' : $includesAll,
		'\$includesNone' : $includesNone,
	};

	factory FilterColumnIncludes.fromJson(Map<String, dynamic> json) => FilterColumnIncludes(
		$includes: FilterPredicate.fromJson(json["\$includes"]),
		$includesAny: FilterPredicate.fromJson(json["\$includesAny"]),
		$includesAll: FilterPredicate.fromJson(json["\$includesAll"]),
		$includesNone: FilterPredicate.fromJson(json["\$includesNone"]),
	);

}

class FilterExpression {
	final String? $exists;
	final String? $existsNot;
	final FilterList? $any;
	final FilterList? $all;
	final FilterList? $none;
	final FilterList? $not;
	const FilterExpression({this.$exists,this.$existsNot,this.$any,this.$all,this.$none,this.$not,});
	Map<String, dynamic> toJson() => {
		'\$exists' : $exists,
		'\$existsNot' : $existsNot,
		'\$any' : $any,
		'\$all' : $all,
		'\$none' : $none,
		'\$not' : $not,
	};

	factory FilterExpression.fromJson(Map<String, dynamic> json) => FilterExpression(
		$exists: json["\$exists"],
		$existsNot: json["\$existsNot"],
		$any: json["\$any"],
		$all: json["\$all"],
		$none: json["\$none"],
		$not: json["\$not"],
	);

}

class FilterList<T> {
	late final T value;
	FilterList(T value) {
		if (value is List<FilterExpression> || value is List<FilterExpression>) {
			this.value = value;
		} else {
			throw Exception('FilterList must be of type List<FilterExpression> or List<FilterExpression>');
		}
	}

	Map<String, dynamic> toJson() => {
		'FilterList': value,
	};

	factory FilterList.fromJson(Map<String, dynamic> json) => FilterList(
		json['FilterList'],
	);

}
class FilterPredicate<T> {
	late final T value;
	FilterPredicate(T value) {
		if (value is List<FilterValue> || value is List<FilterPredicate> || value is List<FilterPredicateOp> || value is List<FilterPredicateRangeOp>) {
			this.value = value;
		} else {
			throw Exception('FilterPredicate must be of type List<FilterValue> or List<FilterPredicate> or List<FilterPredicateOp> or List<FilterPredicateRangeOp>');
		}
	}

	Map<String, dynamic> toJson() => {
		'FilterPredicate': value,
	};

	factory FilterPredicate.fromJson(Map<String, dynamic> json) => FilterPredicate(
		json['FilterPredicate'],
	);

}
class FilterPredicateOp {
	final FilterRangeValue? $lt;
	final FilterRangeValue? $le;
	final FilterRangeValue? $gt;
	final FilterRangeValue? $ge;
	final String? $contains;
	final String? $startsWith;
	final String? $endsWith;
	final String? $pattern;
	const FilterPredicateOp({this.$lt,this.$le,this.$gt,this.$ge,this.$contains,this.$startsWith,this.$endsWith,this.$pattern,});
	Map<String, dynamic> toJson() => {
		'\$lt' : $lt,
		'\$le' : $le,
		'\$gt' : $gt,
		'\$ge' : $ge,
		'\$contains' : $contains,
		'\$startsWith' : $startsWith,
		'\$endsWith' : $endsWith,
		'\$pattern' : $pattern,
	};

	factory FilterPredicateOp.fromJson(Map<String, dynamic> json) => FilterPredicateOp(
		$lt: FilterRangeValue.fromJson(json["\$lt"]),
		$le: FilterRangeValue.fromJson(json["\$le"]),
		$gt: FilterRangeValue.fromJson(json["\$gt"]),
		$ge: FilterRangeValue.fromJson(json["\$ge"]),
		$contains: json["\$contains"],
		$startsWith: json["\$startsWith"],
		$endsWith: json["\$endsWith"],
		$pattern: json["\$pattern"],
	);

}

class FilterPredicateRangeOp {
	final FilterRangeValue? $lt;
	final FilterRangeValue? $le;
	final FilterRangeValue? $gt;
	final FilterRangeValue? $ge;
	const FilterPredicateRangeOp({this.$lt,this.$le,this.$gt,this.$ge,});
	Map<String, dynamic> toJson() => {
		'\$lt' : $lt,
		'\$le' : $le,
		'\$gt' : $gt,
		'\$ge' : $ge,
	};

	factory FilterPredicateRangeOp.fromJson(Map<String, dynamic> json) => FilterPredicateRangeOp(
		$lt: FilterRangeValue.fromJson(json["\$lt"]),
		$le: FilterRangeValue.fromJson(json["\$le"]),
		$gt: FilterRangeValue.fromJson(json["\$gt"]),
		$ge: FilterRangeValue.fromJson(json["\$ge"]),
	);

}

class FilterRangeValue<T> {
	late final T value;
	FilterRangeValue(T value) {
		if (value is num || value is String) {
			this.value = value;
		} else {
			throw Exception('FilterRangeValue must be of type num or String');
		}
	}

	Map<String, dynamic> toJson() => {
		'FilterRangeValue': value,
	};

	factory FilterRangeValue.fromJson(Map<String, dynamic> json) => FilterRangeValue(
		json['FilterRangeValue'],
	);

}
class FilterValue<T> {
	late final T value;
	FilterValue(T value) {
		if (value is num || value is String) {
			this.value = value;
		} else {
			throw Exception('FilterValue must be of type num or String');
		}
	}

	Map<String, dynamic> toJson() => {
		'FilterValue': value,
	};

	factory FilterValue.fromJson(Map<String, dynamic> json) => FilterValue(
		json['FilterValue'],
	);

}
class ListBranchesResponse {
	final String databaseName;
	final String displayName;
	final List<Branch> branches;
	const ListBranchesResponse({required this.databaseName,required this.displayName,required this.branches,});
	Map<String, dynamic> toJson() => {
		'databaseName' : databaseName,
		'displayName' : displayName,
		'branches' : branches,
	};

	factory ListBranchesResponse.fromJson(Map<String, dynamic> json) => ListBranchesResponse(
		databaseName: json["databaseName"],
		displayName: json["displayName"],
		branches: json["branches"],
	);

}

class ListDatabasesResponse {
	const ListDatabasesResponse();
	Map<String, dynamic> toJson() => {
	};

	factory ListDatabasesResponse.fromJson(Map<String, dynamic> json) => ListDatabasesResponse(
	);

}

class MetricsDatapoint {
	final String timestamp;
	const MetricsDatapoint({required this.timestamp,});
	Map<String, dynamic> toJson() => {
		'timestamp' : timestamp,
	};

	factory MetricsDatapoint.fromJson(Map<String, dynamic> json) => MetricsDatapoint(
		timestamp: json["timestamp"],
	);

}

class MetricsLatency {
	final List<MetricsDatapoint>? p50;
	final List<MetricsDatapoint>? p90;
	const MetricsLatency({this.p50,this.p90,});
	Map<String, dynamic> toJson() => {
		'p50' : p50,
		'p90' : p90,
	};

	factory MetricsLatency.fromJson(Map<String, dynamic> json) => MetricsLatency(
		p50: json["p50"],
		p90: json["p90"],
	);

}

class PageConfig {
	final String? after;
	final String? before;
	final String? first;
	final String? last;
	const PageConfig({this.after,this.before,this.first,this.last,});
	Map<String, dynamic> toJson() => {
		'after' : after,
		'before' : before,
		'first' : first,
		'last' : last,
	};

	factory PageConfig.fromJson(Map<String, dynamic> json) => PageConfig(
		after: json["after"],
		before: json["before"],
		first: json["first"],
		last: json["last"],
	);

}

class Record {
	final RecordID id;
	const Record({required this.id,});
	Map<String, dynamic> toJson() => {
		'id' : id,
	};

	factory Record.fromJson(Map<String, dynamic> json) => Record(
		id: json["id"],
	);

}

class RecordsMetadata {
	const RecordsMetadata();
	Map<String, dynamic> toJson() => {
	};

	factory RecordsMetadata.fromJson(Map<String, dynamic> json) => RecordsMetadata(
	);

}

class RevLink {
	final String linkID;
	final String table;
	const RevLink({required this.linkID,required this.table,});
	Map<String, dynamic> toJson() => {
		'linkID' : linkID,
		'table' : table,
	};

	factory RevLink.fromJson(Map<String, dynamic> json) => RevLink(
		linkID: json["linkID"],
		table: json["table"],
	);

}

class Schema {
	final List<Table> tables;
	const Schema({required this.tables,});
	Map<String, dynamic> toJson() => {
		'tables' : tables,
	};

	factory Schema.fromJson(Map<String, dynamic> json) => Schema(
		tables: json["tables"],
	);

}

class SortExpression<T> {
	late final T value;
	SortExpression(T value) {
		if (value is List<String> || value is SortOrder || value is List<SortOrder>) {
			this.value = value;
		} else {
			throw Exception('SortExpression must be of type List<String> or SortOrder or List<SortOrder>');
		}
	}

	Map<String, dynamic> toJson() => {
		'SortExpression': value,
	};

	factory SortExpression.fromJson(Map<String, dynamic> json) => SortExpression(
		json['SortExpression'],
	);

}
class StartedFromMetadata {
	final BranchName branchName;
	final String dbBranchID;
	final String migrationID;
	const StartedFromMetadata({required this.branchName,required this.dbBranchID,required this.migrationID,});
	Map<String, dynamic> toJson() => {
		'branchName' : branchName,
		'dbBranchID' : dbBranchID,
		'migrationID' : migrationID,
	};

	factory StartedFromMetadata.fromJson(Map<String, dynamic> json) => StartedFromMetadata(
		branchName: json["branchName"],
		dbBranchID: json["dbBranchID"],
		migrationID: json["migrationID"],
	);

}

class Table {
	final String? id;
	final TableName name;
	final List<Column> columns;
	final List<RevLink>? revLinks;
	const Table({this.id,required this.name,required this.columns,this.revLinks,});
	Map<String, dynamic> toJson() => {
		'id' : id,
		'name' : name,
		'columns' : columns,
		'revLinks' : revLinks,
	};

	factory Table.fromJson(Map<String, dynamic> json) => Table(
		id: json["id"],
		name: json["name"],
		columns: json["columns"],
		revLinks: json["revLinks"],
	);

}

class TableMigration {
	final List<ColumnMigration>? modifiedColumns;
	const TableMigration({this.modifiedColumns,});
	Map<String, dynamic> toJson() => {
		'modifiedColumns' : modifiedColumns,
	};

	factory TableMigration.fromJson(Map<String, dynamic> json) => TableMigration(
		modifiedColumns: json["modifiedColumns"],
	);

}

class TableRename {
	final String newName;
	final String oldName;
	const TableRename({required this.newName,required this.oldName,});
	Map<String, dynamic> toJson() => {
		'newName' : newName,
		'oldName' : oldName,
	};

	factory TableRename.fromJson(Map<String, dynamic> json) => TableRename(
		newName: json["newName"],
		oldName: json["oldName"],
	);

}

class User {
	final String email;
	final String fullname;
	final String image;
	const User({required this.email,required this.fullname,required this.image,});
	Map<String, dynamic> toJson() => {
		'email' : email,
		'fullname' : fullname,
		'image' : image,
	};

	factory User.fromJson(Map<String, dynamic> json) => User(
		email: json["email"],
		fullname: json["fullname"],
		image: json["image"],
	);

}

class WorkspaceInvite {
	final InviteID inviteId;
	final String email;
	final String expires;
	final Role role;
	const WorkspaceInvite({required this.inviteId,required this.email,required this.expires,required this.role,});
	Map<String, dynamic> toJson() => {
		'inviteId' : inviteId,
		'email' : email,
		'expires' : expires,
		'role' : role,
	};

	factory WorkspaceInvite.fromJson(Map<String, dynamic> json) => WorkspaceInvite(
		inviteId: json["inviteId"],
		email: json["email"],
		expires: json["expires"],
		role: json["role"],
	);

}

class WorkspaceMember {
	final UserID userId;
	final String fullname;
	final String email;
	final Role role;
	const WorkspaceMember({required this.userId,required this.fullname,required this.email,required this.role,});
	Map<String, dynamic> toJson() => {
		'userId' : userId,
		'fullname' : fullname,
		'email' : email,
		'role' : role,
	};

	factory WorkspaceMember.fromJson(Map<String, dynamic> json) => WorkspaceMember(
		userId: json["userId"],
		fullname: json["fullname"],
		email: json["email"],
		role: json["role"],
	);

}

class WorkspaceMembers {
	final List<WorkspaceMember> members;
	final List<WorkspaceInvite> invites;
	const WorkspaceMembers({required this.members,required this.invites,});
	Map<String, dynamic> toJson() => {
		'members' : members,
		'invites' : invites,
	};

	factory WorkspaceMembers.fromJson(Map<String, dynamic> json) => WorkspaceMembers(
		members: json["members"],
		invites: json["invites"],
	);

}

class WorkspaceMeta {
	final String name;
	final String slug;
	const WorkspaceMeta({required this.name,required this.slug,});
	Map<String, dynamic> toJson() => {
		'name' : name,
		'slug' : slug,
	};

	factory WorkspaceMeta.fromJson(Map<String, dynamic> json) => WorkspaceMeta(
		name: json["name"],
		slug: json["slug"],
	);

}

